{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Monaco;
}
{\colortbl;\red255\green255\blue255;\red242\green242\blue242;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid2\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1440\margr1440\vieww17940\viewh12780\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\b\fs24 \cf0 Code Requirements:\

\b0 \
\pard\tx220\tx720\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li720\fi-720\pardirnatural\partightenfactor0
\ls1\ilvl0\cf0 {\listtext	\'95	}The code was developed using python 2.7\
{\listtext	\'95	}The following packages are required:\
\pard\tx940\tx1440\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li1440\fi-1440\pardirnatural\partightenfactor0
\ls1\ilvl1\cf0 {\listtext	\uc0\u8259 	}pandas to split the data. Though I could (and, given more time, would) have used a different, purely pythonic way of splitting the data, this was fastest for me.\
{\listtext	\uc0\u8259 	}heapq to implement a priority queue for Dijkstra\'92s algorithm. I could have implemented a heap class myself, but this is what I could practically do.\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \

\b Notes:
\b0 \
\
\pard\tx220\tx720\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\li720\fi-720\pardirnatural\partightenfactor0
\ls2\ilvl0\cf0 {\listtext	1.	}As mentioned, I chose to a shortest path algorithm to find the values. More specifically, I chose to use Dijkstra\'92s algorithm as \'93\expnd0\expndtw0\kerning0
This is asymptotically the fastest known single-source shortest-path algorithm for arbitrary directed graphs with unbounded non-negative weights\kerning1\expnd0\expndtw0 \'94 {\field{\*\fldinst{HYPERLINK "https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"}}{\fldrslt \expnd0\expndtw0\kerning0
[1]}}\expnd0\expndtw0\kerning0
. Based on this statement, the algorithm can be applied to more problems in the future.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2.	}I chose to parse the values in a dictionary using the function 
\f1\fs22 \CocoaLigature0 values_to_dict
\f0\fs24 \CocoaLigature1 . with the format \{\'93start_node\'93\{\'93end_node\'93,\'93distance\'93\}\}. This ensured that fast access to data was available, as dictionaries are based on hash tables. \expnd0\expndtw0\kerning0
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0
\cf0 \kerning1\expnd0\expndtw0 \

\b Running Code:
\b0 \
\
The code is run using the following command, which contains three arguments:\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f1\fs22 \cf0 \CocoaLigature0 ./run.sh \{data_name\} \{starting_node\} \{end_node\}
\f0\fs24 \CocoaLigature1 \
\
For example:\
\
 
\f2\fs20 \cf2 \cb0 \CocoaLigature0 ./run.sh map_data.dat 316319897 316319936\
}